        - 
        - #### Funcions necessaries per a l'article exclÃºsivament ############
        - 
        - import LightGraphs as lg
        - 
        - 
        - """
        -     create_qft_circuit_bis(n::Integer)
        - 
        - Creates a Quantum Fourier Transform (QFT) circuit with `n` qubits.
        - 
        - # Arguments
        - - `n::Integer`: The number of qubits in the circuit.
        - 
        - # Returns
        - - `Circ`: A QFT circuit object with the specified number of qubits.
        - 
        - # Notes
        - This function initializes a QFT circuit and applies controlled-X gates as part of its structure.
        - """
        - function create_qft_circuit_bis(n::Integer)
        -     circ = QXZoo.Circuit.Circ(n)
        -     QXZoo.QFT.apply_qft!(circ, collect(1:n))
        -     QXZoo.Circuit.add_gatecall!(circ, QXZoo.DefaultGates.c_x(1, 2))
        -     QXZoo.Circuit.add_gatecall!(circ, QXZoo.DefaultGates.c_x(2, 3))
        -     circ
        - end
        - 
        - function create_qft_circuit(n::Integer)
        -     circ = QXZoo.Circuit.Circ(n)
        -     # Apply QFT to all qubits
        -     QXZoo.QFT.apply_qft!(circ, collect(1:n))
        -     
        -     # Add controlled gates only if n >= 3
        -     if n >= 2
        -         QXZoo.Circuit.add_gatecall!(circ, QXZoo.DefaultGates.c_x(1, 2))
        -     end
        -     if n >= 3
        -         QXZoo.Circuit.add_gatecall!(circ, QXZoo.DefaultGates.c_x(2, 3))
        -     end
        -     circ
        - end
        - # **************************************************************************************** #
        - #                          Functions for creating various graphs
        - # **************************************************************************************** #
        - 
        - """
        -     line_graph_tris(G::LabeledGraph)
        - 
        - Creates the line graph of the input labeled graph `G`.
        - 
        - # Arguments
        - - `G::LabeledGraph`: The input labeled graph.
        - 
        - # Returns
        - - `LabeledGraph`: A line graph where each vertex represents an edge in the original graph.
        -   The label for each vertex in the line graph is generated by concatenating the labels of
        -   the vertices connected by the corresponding edge in the input graph.
        - 
        - # Notes
        - The function orders the vertex labels of each edge to ensure consistent labeling.
        - """
        - function line_graph_tris(G::LabeledGraph)
       96     vertex_labels::Array{Symbol, 1}=[]
        -     
        0     G_edges = collect(QXGraphDecompositions.edges(G))
        -     #vertex_labels = [QXGraphDecompositions.combine_labels(G.labels[e.src], G.labels[e.dst]) for e in G_edges]
        -    
     4448     for e in G_edges
        0        if e.src < e.dst
     3312                 etiqueta=Symbol(G.labels[e.src], :_, G.labels[e.dst])
     1904                 push!(vertex_labels,etiqueta)
        -                 
        -             else
        0                 etiqueta=Symbol(G.labels[e.dst], :_, G.labels[e.src])
        0                 push!(vertex_labels,etiqueta)
        -             end
     4384     end
        -     
       32     line_graph_tris(G.graph; vertex_labels=vertex_labels)
        - end
        - 
        - """
        -     line_graph_tris(G::lg.AbstractGraph; vertex_labels::Array{Symbol, 1}=Symbol[])
        - 
        - Creates the line graph of the input abstract graph `G`.
        - 
        - # Arguments
        - - `G::lg.AbstractGraph`: The input abstract graph.
        - - `vertex_labels::Array{Symbol, 1}=Symbol[]`: An optional array of symbols used as vertex labels.
        -   If left empty, labels are generated by concatenating the indices of the corresponding vertices in `G`.
        - 
        - # Returns
        - - `LabeledGraph`: A labeled graph where:
        -   - Each vertex represents an edge in the input graph.
        -   - Edges are added between vertices in the line graph if the corresponding edges in the input graph share a vertex.
        - 
        - # Notes
        - If no custom `vertex_labels` are provided, the function generates them by combining the indices of the vertices connected by each edge in the input graph.
        - """
        0 function line_graph_tris(G::lg.AbstractGraph; 
        -                     vertex_labels::Array{Symbol, 1}=Symbol[])
        -     # Create a labeled graph LG whose vertices corresponding to the edges of G.
        -     
     2368     G_edges = collect(lg.edges(G))
        0     if isempty(vertex_labels)
        -         #vertex_labels = [QXGraphDecompositions.combine_labels(e.src, e.dst) for e in G_edges]
        -         #vertex_labels=[]
        0         for e in G_edges
        0             if e.src < e.dst
        0                 etiqueta=Symbol(G.labels[e.src], :_, G.labels[e.dst])
        -                 push!(vertex_labels,etiqueta)
        -                 
        -             else
        0                 etiqueta=Symbol(G.labels[e.dst], :_, G.labels[e.src])
        -                 push!(vertex_labels,etiqueta)
        -             end
        -         end
        -     end
      368     LG = LabeledGraph(lg.SimpleGraph(length(G_edges)), vertex_labels)
        - 
        -     # Connect any two vertices of LG whose corresponding edges in G share a vertex in G.
        0     for i in 1:length(G_edges)-1
        0         for j in i+1:length(G_edges)
        0             u = G_edges[i]
        0             v = G_edges[j]
        0             if (u.src == v.src) || (u.src == v.dst) || (u.dst == v.src) || (u.dst == v.dst)
        0                 QXGraphDecompositions.add_edge!(LG, i, j)
        -             end
        0         end
        0     end
        0     LG
        - end
        - 
        - 
        - """
        -     GN_pla(g::AbstractGraph, tnc_tn::TensorNetwork)
        - 
        - Generates a contraction plan for a tensor network based on the Girvan-Newman (GN) algorithm.
        - 
        - # Arguments
        - - `g::AbstractGraph`: The input abstract graph.
        - - `tnc_tn::TensorNetwork`: The tensor network to be contracted.
        - 
        - # Returns
        - - `Array{Tuple{Symbol, Symbol, Symbol}, 1}`: A contraction plan represented as an ordered list of pairs of tensors to contract.
        - 
        - # Notes
        - This function uses the Girvan-Newman algorithm to detect communities in the graph, which are then converted into a contraction plan for the tensor network.
        - """
        - 
        -  
        - function GN_pla(g::AbstractGraph, tnc_tn::TensorNetwork)::Array{Tuple{Symbol, Symbol, Symbol}, 1}
        -         
        -      h_ig=lg2ig(g) 
        - 
        -      comunitat=ordenacio_girvan_igraph(h_ig)
        -      
        -      ordenacio=Vector{Symbol}[]
        -      for i in comunitat
        -         parella=[]
        -     
        -         tensor_1= Symbol("t"*(string(i[1])))
        -         tensor_2= Symbol("t"*(repr(i[2]))) 
        -         push!(parella,tensor_1,tensor_2)
        -         push!(ordenacio,parella)
        -      end
        -       
        -         pla=order_to_contraction_plan(ordenacio,tnc_tn)
        -   end
        - 
        - 
        - """
        -     GN_pla(g::AbstractGraph, vmap::Array{Int64, 1}, tnc_tn::TensorNetwork)
        - 
        - Generates a contraction plan for a tensor network based on the Girvan-Newman (GN) algorithm,
        - using a vertex mapping.
        - 
        - # Arguments
        - - `G::AbstractGraph`: The input abstract graph.
        - - `vmap::Array{Int64, 1}`: using as a mapping of vertex indices to symbolic tensor names.
        - - `tnc_tn::TensorNetwork`: The tensor network to be contracted.
        - 
        - # Returns
        - - `Array{Tuple{Symbol, Symbol, Symbol}, 1}`: A contraction plan represented as an ordered list of pairs of tensors to contract.  A contraction plan for the tensor network.
        - # Notes
        - This version of the function uses the vertex mapping `vmap` to resolve symbolic names for the tensors in the contraction plan.
        - """
        - 
        - 
        - function  GN_pla(g::AbstractGraph, vmap::Array{Int64, 1}, tnc_tn::TensorNetwork)
        -         
        -      # Convert the input graph into its Python igraph representation
        0     h_ig = lg2ig(g)
        - 
        -     # Perform community detection using the Girvan-Newman algorithm
        0     comunitat = ordenacio_girvan_igraph(h_ig)
        - 
        -     # Generate a contraction order based on the community structure and vertex mapping
      192     ordenacio = Vector{Symbol}[]
        0     for i in comunitat
     6048         parella = []
        - 
     3024         tensor_1 = Symbol("t" * string(vmap[i[1]]))
     3024         tensor_2 = Symbol("t" * repr(vmap[i[2]]))
     4032         push!(parella, tensor_1, tensor_2)
        0         push!(ordenacio, parella)
        0     end
        - 
        -     # Convert the contraction order into a contraction plan
        0      pla=order_to_contraction_plan(ordenacio,tnc_tn)
        -     
        -       
        -     
        -   end
        - 
        - 
        -     
        - 
        - 
        - 
        - 
        - 
        - # **************************************************************************************** #
        - #       Converting edge elimination orders & contraction trees into contraction plans
        - # **************************************************************************************** #
        - 
        - 
        - """
        -     order_to_contraction_plan(elimination_order::Array{<:Array{Symbol, 1}, 1},
        -                               tn::Union{TensorNetwork, OrderedDict{Symbol, Array{Index, 1}}}
        -                               )::Array{NTuple{3, Symbol}, 1}
        - 
        - Converts an edge elimination order into a contraction plan for the input tensor network.
        - 
        - # Arguments
        - - `elimination_order::Array{Array{Symbol, 1}, 1}`: The order in which tensor edges should be eliminated,
        -   represented as an array of symbol arrays.
        - - `tn::Union{TensorNetwork, OrderedDict{Symbol, Array{Index, 1}}}`: The tensor network or its dictionary
        -   representation. If a dictionary is provided, keys are tensor IDs and values are arrays of indices associated
        -   with each tensor.
        - 
        - # Returns
        - - `Array{NTuple{3, Symbol}, 1}`: A contraction plan, where each tuple `(A_id, B_id, I_id)` represents:
        -   - `A_id` and `B_id`: IDs of tensors being contracted.
        -   - `I_id`: ID of the resulting intermediate tensor.
        - 
        - # Notes
        - This function generates a sequence of tensor contractions based on an elimination order. Intermediate tensors
        - are created dynamically during the process, and their mapping is updated iteratively.
        - """
        - 
        - function order_to_contraction_plan(elimination_order::Array{Array{Symbol, 1}, 1},
        -                                    tn::Union{TensorNetwork, OrderedDict{Symbol, Array{Index, 1}}}
        -                                    )::Array{NTuple{3, Symbol}, 1}
        -     # An array to hold the contraction plan.
      320     plan = Array{NTuple{3, Symbol}, 1}()
        - 
        -     # A dictionary to keep track of which tensors are replaced by which intermediate tensors
        -     # at different stages of the contraction process. Initially, before any pairwise
        -     # contractions, none of the tensors are replaced by intermediates, so all tensor ids are
        -     # mapped to themselves.
    17120     intermediate_tensor_map = Dict{Symbol, Symbol}(keys(tn) .=> keys(tn))
        - 
        -     # Convert each edge in the elimination order to a set of pairwise contractions and
        -     # append it to plan.
        0     for (i, edge) in enumerate(elimination_order)
        0         if length(edge) == 2
        -             # For edges consisting of just two tensors, find the intermediates they belong
        -             # to and add their pairwise contraction to the plan.
        0             A_id = _get_intermediate_tensor(intermediate_tensor_map, edge[1])
        0             B_id = _get_intermediate_tensor(intermediate_tensor_map, edge[2])
        0             if !(A_id == B_id)
        -                 # id for the new intermediate created by contracting A_id and B_id.
    30256                 I_id = Symbol("I$i")
     9760                 append!(plan, [(A_id, B_id, I_id)])
        - 
        -                 # Update intermediate_tensor_map with new intermediate.
        0                 intermediate_tensor_map[A_id] = I_id
        0                 intermediate_tensor_map[B_id] = I_id
        0                 intermediate_tensor_map[I_id] = I_id
        -             end
        - 
        0         elseif length(edge) > 2
        -             # For edges with more than 2 tensors, collect all of the tensors and
        -             # intermediate tensors that belong to the edge and find a contraction plan for
        -             # them. Append the contraction this plan to plan.
        0             tensors_to_contract = OrderedDict{Symbol, Array{Index, 1}}()
        0             for t_id in edge
        0                 I_id = _get_intermediate_tensor(intermediate_tensor_map, t_id)
        0                 inds = typeof(tn) <: TensorNetwork ? QXTns.inds(tn[t_id]) : tn[t_id]
        0                 tensors_to_contract[I_id] = symdiff(get(tensors_to_contract, I_id, []), inds)
        0             end
        0             if length(tensors_to_contract) > 1
        -                 # Check if netcon can be used on the given set of tensors. If not, use
        -                 # a fallback method to find a contraction plan.
        0                 tensor_sizes = prod.([QXTns.dim.(inds) for inds in values(tensors_to_contract)])
        0                 if length(tensors_to_contract) < 37 && any(tensor_sizes .< 2^62)
        0                     local_contraction_plan = netcon(tn, tensors_to_contract)
        -                 else
        0                     local_contraction_plan = min_fill_contraction_plan(tensors_to_contract)
        -                 end
        0                 append!(plan, local_contraction_plan)
        - 
        -                 # Update intermediate_tensor_map with new intermediates.
        0                 for (A_id, B_id, I_id) in local_contraction_plan
        0                     intermediate_tensor_map[A_id] = I_id
        0                     intermediate_tensor_map[B_id] = I_id
        0                     intermediate_tensor_map[I_id] = I_id
        0                 end
        -             end
        -         end
        0     end
        0     plan
        - end
        - 
        - 
        - 
        - 
        - """
        -     _get_intermediate_tensor(intermediate_tensor_map::Dict{Symbol, Symbol}, t_id::Symbol)::Symbol
        - 
        - Retrieves the ID of the intermediate tensor associated with the given tensor `t_id`.
        - 
        - # Arguments
        - - `intermediate_tensor_map::Dict{Symbol, Symbol}`: A mapping that tracks which tensors have been replaced
        -   by intermediate tensors during the contraction process.
        - - `t_id::Symbol`: The ID of the tensor for which the intermediate tensor is being queried.
        - 
        - # Returns
        - - `Symbol`: The ID of the intermediate tensor that represents the final state of `t_id`. 
        -   If `t_id` has not been replaced, it returns `t_id` itself.
        - 
        - # Notes
        - The function iteratively traverses the `intermediate_tensor_map` to find the final intermediate tensor
        - associated with the input `t_id`. It stops when the tensor ID maps to itself, indicating that it has
        - not yet been replaced.
        - """
        - function _get_intermediate_tensor(intermediate_tensor_map::Dict{Symbol, Symbol}, t_id::Symbol)::Symbol
        -     while true
        -         I_id = intermediate_tensor_map[t_id]
        -         # If t_id = I_id then t_id has not been replaced by an intermediate tensor yet.
        -         (t_id == I_id) && return I_id
        -         t_id = I_id
        -     end
        - end
        - 
        - 
        - 
        - """
        -     lg2ig(lg_g::AbstractGraph)::igraph.Graph
        - 
        - Converts a Julia `AbstractGraph` into a Python `igraph.Graph`.
        - 
        - # Arguments
        - - `lg_g::AbstractGraph`: The input graph in Julia.
        - 
        - # Returns
        - - `igraph.Graph`: A Python `igraph` representation of the input graph as a  PyObject
        - 
        - # Notes
        - 1. This function ensures compatibility between Julia's `AbstractGraph` and Python's `igraph`.
        - 2. Julia's 1-based indexing is adjusted to Python's 0-based indexing.
        - 3. For more details on the Python `igraph` library, visit: https://python.igraph.org/en/latest/index.html
        - """
        - ig = pyimport("igraph");
        - 
        - 
        - function lg2ig(lg_g::AbstractGraph)
        -     # Initialize a Python igraph Graph with the same number of vertices as the input graph
        0     i_g = ig.Graph(LightGraphs.nv(lg_g))
        - 
        -     # Collect edges from the input graph and adjust indices for Python's 0-based indexing
      288     arestes = []
        0     for e in LightGraphs.edges(lg_g)
        0         a=(LightGraphs.src(e)-1,LightGraphs.dst(e)-1)
    19824         push!(arestes, a)
        0     end
        - 
        -     # Add edges to the Python igraph Graph
        0     i_g.add_edges(arestes)
        - 
        -     # Return the constructed igraph Graph as a PyObject 
        0     return i_g
        - end
        - 
        - 
        - 
        - """
        -     ordenacio_girvan_igraph(h::PyObject)::Vector{Tuple{Int, Int}}
        - 
        - Applies the Girvan-Newman (GN) algorithm to a Python `igraph.Graph` and returns an edge elimination order.
        - 
        - # Arguments
        - - `h::PyObject`: A Python `igraph.Graph` object. 
        - 
        - # Returns
        - - `Vector{Tuple{Int, Int}}`: A reversed list of edges (as pairs of vertex indices) ordered by their removal in the GN algorithm.
        - 
        - # Notes
        - 1. The Girvan-Newman algorithm iteratively removes edges with the highest betweenness centrality to identify community structures.
        - 2. This function generates an ordered list of edge removals based on the algorithm.
        - 3. Vertex indices are converted from Python's 0-based indexing to Julia's 1-based indexing for compatibility.
        - 
        - # See Also
        - For more details on `igraph` and the Girvan-Newman algorithm, visit: https://python.igraph.org/en/latest/index.html
        - """
        - 
        - 
        - function ordenacio_girvan_igraph(h)
        -     # Initialize an empty list to store the order of edge removals
      192     eixida = []
        - 
        -     # Iteratively remove edges based on edge betweenness
      256     for _ in 1:length(h.get_edgelist())
        -         # Compute edge betweenness values
        0         edge_betweenness = h.edge_betweenness()
        - 
        -         # Find the edge with the maximum betweenness
     4032         aresta = findmax(edge_betweenness)[2]
        0         e = h.es[aresta]
     4032         edge = e.source+1, e.target+1   # Convert indices to 1-based
        - 
        -         # Append the edge to the elimination order
     3152         push!(eixida, edge)
        - 
        -         # Remove the edge from the graph
     4032         id = h.get_eid(e.source, e.target)
     2016         h.delete_edges(id)
     3904     end
        - 
        -     # Reverse the order of eliminations to reflect final removal order
     1280     eixida_inv = reverse(eixida)
        - 
        -     # Return the reversed edge elimination order
        0     return eixida_inv
        - end
        - 
        - 
        - 
        - 
        - """
        -     labelg_to_communitats_between(labeled_light_graf::LabeledGraph, clusters::Int)
        - 
        - Identifies communities in a labeled graph using edge betweenness and computes their modularity.
        - 
        - # Arguments
        - - `labeled_light_graf::LabeledGraph`: The input labeled graph.
        - - `clusters::Int`: The number of clusters to detect. If set to `0`, the algorithm automatically determines the number of clusters.
        - 
        - # Returns
        - - `Vector{Vector{Int}}`: A Julia-style representation of communities, where each community is a vector of vertex indices.
        - - `Array{Array{Int64, 1}, 1}`: A Python-style representation of communities.
        - - `Float64`: The modularity score of the detected community structure.
        - 
        - # Notes
        - 1. The function uses the `community_edge_betweenness` method from the Python `igraph` library to detect communities.
        - 2. Vertex indices are converted from Python's 0-based indexing to Julia's 1-based indexing.
        - 3. The modularity score measures the quality of the detected community structure.
        - 
        - # See Also
        - For more information on `igraph` and community detection, visit: https://python.igraph.org/en/latest/index.html
        - """
        - 
        - 
        - function labelg_to_communitats_between(labeled__light_graf::LabeledGraph,clusters::Int)
        -         # Convert the labeled graph to a Python igraph representation
        0         h_Lg_ig=lg2ig(labeled__light_graf.graph);
        -         # Perform community detection using edge betweenness
        0         if clusters==0
        0             communities_Lg =h_Lg_ig.community_edge_betweenness( ) 
        -         else
       16             communities_Lg =h_Lg_ig.community_edge_betweenness(clusters=clusters) 
        -         end
        -         # Convert the detected communities into a clustering
        0         communities_Lg = communities_Lg.as_clustering();
        -         # Convert Python-style communities to Julia-style
        0         comunitats_betwenness=py"""list"""(communities_Lg);
       48         comunitats_julia=[];
        -     
        0         for i in comunitats_betwenness
      256             planet=Int[]
      256             for j in 1:length(i)
        0             push!(planet,i[j]+1) # Adjust to 1-based indexing
     3808             end
       80         push!(comunitats_julia,planet)
        0         end
        -         # Compute the modularity of the detected communities
        0         modularitat=h_Lg_ig.modularity(communities_Lg) 
        -       # Return the Julia-style communities, Python-style communities, and modularity
      160     return comunitats_julia,comunitats_betwenness,modularitat
        - end
        - 
        - 
        - """
        -     labelg_to_communitats_fastgreedy(labeled__light_graf::LabeledGraph)
        - 
        - Detects communities in a labeled graph using the Fast Greedy algorithm and computes the modularity of the detected community structure.
        - 
        - # Arguments
        - - `labeled__light_graf::LabeledGraph`: The labeled graph to analyze.
        - 
        - # Returns
        - - `Array{Array{Int64, 1}, 1}`: A Julia-style representation of communities.
        - - `Array{Array{Int64, 1}, 1}`: A Python-style representation of communities.
        - - `Float64`: The modularity score of the detected community structure.
        - 
        - # Notes
        - 1. The function uses the `community_fastgreedy` method from the Python `igraph` library to detect communities.
        - 2. Vertex indices are converted from Python's 0-based indexing to Julia's 1-based indexing.
        - 3. The modularity score measures the quality of the detected community structure.
        - """
        - function labelg_to_communitats_fastgreedy(labeled__light_graf::LabeledGraph)
        -     # Convert labeled graph to igraph format
        -     h_Lg_ig = lg2ig(labeled__light_graf.graph)
        -     
        -     # Detect communities using the Fast Greedy algorithm
        -     communities_Lg = h_Lg_ig.community_fastgreedy() # Obtain optimal communities based on modularity
        -     
        -     # Convert the detected communities to clustering format
        -     communities_Lg = communities_Lg.as_clustering()
        -     
        -     # Convert the communities to a Python list
        -     comunitats_betwenness = py"""list"""(communities_Lg)
        -     
        -     # Initialize an empty array to store the communities in Julia format
        -     comunitats_julia = []
        -     
        -     # Convert community indices from Python's 0-based indexing to Julia's 1-based indexing
        -     for i in comunitats_betwenness
        -         planet = Int[]
        -         for j in 1:length(i)
        -             push!(planet, i[j] + 1)
        -         end
        -         push!(comunitats_julia, planet)
        -     end
        -     
        -     # Compute the modularity of the detected community structure
        -     modularitat = h_Lg_ig.modularity(communities_Lg)
        -     
        -     # Return the communities in Julia format, Python format, and the modularity score
        -     return comunitats_julia, comunitats_betwenness, modularitat
        - end
        - 
        - 
        - 
        - """
        -     pla_contraccio_multiple_G_N(nova_llista_comunitats_julia::Array{Any, 1}, 
        -                                 tnc::TensorNetworkCircuit, 
        -                                 g::AbstractGraph)
        - 
        - Generates contraction plans and tensor networks for each community in a list of communities.
        - 
        - # Arguments
        - - `nova_llista_comunitats_julia::Array{Any, 1}`: A list of communities, where each community is represented as a vector of vertex indices.
        - - `tnc::TensorNetworkCircuit`: The tensor network circuit containing the tensor mappings.
        - - `g::AbstractGraph`: The input graph representing the full tensor network.
        - 
        - # Returns
        - - `Vector{TensorNetwork}`: A list of tensor networks, one for each community.
        - - `Vector{Array}`: A list of contraction plans, one for each community.
        - 
        - # Notes
        - 1. For each community, a contraction plan is generated using the Girvan-Newman algorithm.
        - 2. Tensor networks are created for each community by mapping the community nodes to their respective tensors.
        - 3. The function organizes the communities into independent tensor networks for parallel or individual processing.
        - """
        - 
        - 
        - 
        - import QXGraphDecompositions
        - 
        - function pla_contraccio_multiple_G_N(nova_llista_comunitats_julia::Array{Any, 1},tnc::TensorNetworkCircuit,  g::AbstractGraph)
        - 
        -     # List to store contraction plans for each community
       48        plans=[] 
        -      # Generate contraction plans for each community
        0  for i in 1:length(nova_llista_comunitats_julia)
        0     subgraf=nova_llista_comunitats_julia[i]
      128     sg, vmap = LightGraphs.induced_subgraph(g, subgraf)
        0     vmap_s =Symbol.(vmap)
        -          
        0    pla_comunitat=GN_pla(sg,vmap,tnc.tn)
       80   push!(plans,pla_comunitat)
        0 end
        -        
       48     comunitats_x=[] 
        -     # Generate contraction plans for each community
        0 for j in 1:length(nova_llista_comunitats_julia)
       64    comunitat=[ Symbol("t$i")   for i in nova_llista_comunitats_julia[j]]
       80    push!(comunitats_x,comunitat) 
        0 end
        - 
        - # Create tensor networks for each community
        - 
       48 tns=[]
        0  for j in 1:length(nova_llista_comunitats_julia)
      192     tensors_c=[]
      128     for i in comunitats_x[j]
     3152        push!(tensors_c,tnc.tn.tensor_map[i])
     3808     end
     1200     tensors_c=Vector{ QXTensor}(tensors_c)
        -   
        0     tn=TensorNetwork(tensors_c,comunitats_x[j])
       80     push!(tns,tn)
        0 end
        -    # Return the list of tensor networks and their respective contraction plans
        0    return tns,plans
        - end
        - 
        - 
        - """
        -     TensorNetwork(array::Vector{<:QXTensor}, comunitat::Vector{Symbol})
        - 
        - Creates a tensor network object (subnetwork) from an array of tensors and a corresponding array of symbolic names.
        - 
        - # Arguments
        - - `array::Vector{<:QXTensor}`: An array of tensors, each represented as a `QXTensor` object.
        - - `comunitat::Vector{Symbol}`: An array of symbolic names representing the tensors in the network.
        - 
        - # Returns
        - - `TensorNetwork`: A new tensor network object containing:
        -   - `tensor_map`: A mapping of symbolic tensor names to their corresponding tensors.
        -   - `bond_map`: A mapping of bonds to the tensors they connect.
        -   - `next_id`: The ID for the next intermediate tensor.
        - 
        - # Notes
        - 1. The function maps each tensor in the `array` to a unique symbolic name provided in `comunitat`.
        - 2. It constructs a bond map to track which tensors are connected via shared bonds, facilitating efficient contraction.
        - """
        - 
        - 
        - 
        - using ITensors
        - using LinearAlgebra
        - using NDTensors
        - 
        - 
        - function TensorNetwork(array::Vector{<: QXTensor},comunitat::Vector{Symbol})
        -      # Initialize the tensor map and bond map
        0     tensor_map = OrderedDict{Symbol, QXTensor}()
        0     bond_map = OrderedDict{Index, Vector{Symbol}}()
        -     # ID counter for intermediate tensors
        -     next_id = 1
        -     # Populate the tensor map and bond map
        0     for t in array
        0         tensor_id = Symbol(comunitat[next_id])
        0         next_id += 1
        0         tensor_map[tensor_id] = t
    13776         for bond in inds(t)
        0             if haskey(bond_map, bond)
    10080                 push!(bond_map[bond], tensor_id)
        -             else
     9600                 bond_map[bond] = [tensor_id]
        -             end
    17136         end
        0     end
        -      # Return the constructed tensor network
      128     TensorNetwork(tensor_map, bond_map, next_id)
        - end
        - 
        - 
        - """
        -     primera_contraccio_paral(tns::Vector{TensorNetwork}, plans::Vector{Array{Tuple{Symbol, Symbol, Symbol}, 1}}})
        - 
        - Performs the first parallel contraction phase, merging multiple tensor networks into a single unified network.
        - 
        - # Arguments
        - - `tns::Vector{TensorNetwork}`: A vector of tensor networks, one for each community.
        - - `plans::Vector{Array{Tuple{Symbol, Symbol, Symbol}, 1}}}`: A vector of contraction plans, where each plan corresponds to a tensor network in `tns`.
        - 
        - # Returns
        - - `TensorNetwork`: A single tensor network resulting from the contraction and merging of all input networks.
        - 
        - # Notes
        - 1. The function first applies parallel contraction to each tensor network using the provided plans.
        - 2. After parallel contraction, all tensor networks are merged into a single unified network.
        - """
        - 
        - 
        - function primera_contraccio_paral(tns::Vector{Any},plans::Vector{Any})
        -     # Perform parallel contraction on each tensor network using the respective plans
      320     contraccio_paral(tns, plans)
        -     # Initialize an empty tensor network to hold the merged result
       32     c=TensorNetwork() 
        -     # Merge all contracted tensor networks into the unified network
        0     for i in 1: length(tns)
        -    
        0           c=Base.merge(c, tns[i])
        0     end
        -     # Return the unified tensor network
        0     return c 
        -    
        - end
        - 
        - 
        - """
        -     contraccio_paral(tns::Vector{TensorNetwork}, plans::Vector{Array{Tuple{Symbol, Symbol, Symbol}, 1}})
        - 
        - Performs parallel contraction of tensor networks using the provided contraction plans.
        - 
        - # Arguments
        - - `tns::Vector{TensorNetwork}`: A vector of tensor networks to be contracted.
        - - `plans::Vector{Array{Tuple{Symbol, Symbol, Symbol}, 1}}`: A vector of contraction plans, where each plan corresponds to a tensor network in `tns`.
        - 
        - # Returns
        - - `Vector{TensorNetwork}`: The vector of tensor networks after applying the contractions.
        - 
        - # Notes
        - 1. This function uses multithreading (`Base.Threads.@threads`) to contract multiple tensor networks in parallel.
        - 2. Each tensor network in `tns` is contracted independently according to its corresponding contraction plan in `plans`.
        - 3. The `@sync` ensures that all parallel tasks are completed before proceeding.
        - """
        - 
        - using DataStructures
        - using Distributed
        - 
        - function contraccio_paral(tns::Vector{Any},plans::Vector{Any})
        -     # Perform parallel contractions for all tensor networks using their respective plans
        -     
        -    @sync   Base.Threads.@threads for i in 1:length(tns)
        -        contract_tn!(tns[i], plans[i])  # Apply the contraction plan to the tensor network
        -     end
        -     # Return the tensor networks after contraction
        -      tns
        - end
        - 
        - """
        -     min_fill_contraction_plan_tw(tn::TensorNetwork; hypergraph::Bool=false)
        - 
        - Generates a contraction plan and computes the treewidth for the input tensor network using the min-fill heuristic.
        - 
        - # Arguments
        - - `tn::TensorNetwork`: The input tensor network for which the contraction plan is generated.
        - - `hypergraph::Bool=false`: If `true`, considers hyperedges when constructing the line graph.
        - 
        - # Returns
        - - `Int`: The treewidth of the tensor network.
        - - `Array{Tuple{Symbol, Symbol, Symbol}, 1}`: A contraction plan for the tensor network.
        - 
        - # Notes
        - 1. The function converts the tensor network into a line graph representation.
        - 2. It uses the min-fill heuristic from `QXGraphDecompositions` to compute the treewidth and generate an elimination order.
        - 3. The elimination order is converted into a contraction plan.
        - 4. This function is essential for efficient contraction planning in tensor networks.
        - """
        - 
        - 
        - 
        - import QXGraphDecompositions as qxg
        - import LightGraphs
        - 
        - function min_fill_contraction_plan_tw(tn::TensorNetwork;hypergraph::Bool=false)
        -     # Convert tn to a line graph and pass it to flow cutter to find an tree decomposition.
        -     lg, symbol_map = convert_to_line_graph(tn, use_hyperedges=hypergraph)
        - 
        -     # Use flow cutter to try find a tree decomposition of the line graph.
        -     tw, order = qxg.min_fill(lg)
        - 
        -     # Convert the elimination order to an array of Index structs in tn.
        -     order = [symbol_map[lg_vertex] for lg_vertex in order]
        - 
        -     # Convert the elimination order into a contraction plan.
        -     pla = order_to_contraction_plan(order, tn)
        -     return tw,pla 
        - end
        - 
        - min_fill_contraction_plan_tw(tnc::TensorNetworkCircuit; kwargs...) = min_fill_contraction_plan_tw(tnc.tn; kwargs...)
        - 
        - 
        - """
        -     pla_paral_p(c::TensorNetwork, pla::Array{Tuple{Symbol, Symbol, Symbol}, 1})
        - 
        - Reorganizes a contraction plan into parallelizable and sequential elements.
        - 
        - # Arguments
        - - `c::TensorNetwork`: The unified tensor network after the first parallel contraction phase.
        - - `pla::Array{Tuple{Symbol, Symbol, Symbol}, 1}`: The sequential contraction plan, which could be generated using algorithms like min-fill or FlowCutter.
        - 
        - # Returns
        - - `Array{Tuple{Symbol, Symbol, Symbol}, 1}`: A reordered contraction plan with parallelizable elements first, followed by the remaining sequential elements.
        - - `Int`: The number of parallelizable elements in the contraction plan.
        - 
        - # Notes
        - 1. The function separates the contraction steps into parallelizable and non-parallelizable categories.
        - 2. Parallelizable steps are those whose tensors exist in the keys of the tensor network `c`.
        - 3. The output plan starts with parallelizable elements followed by sequential ones.
        - """
        - 
        - 
        - 
        - function pla_paral_p(c::TensorNetwork,pla::Array{Tuple{Symbol, Symbol, Symbol}, 1})
        -     # Lists to store parallelizable and non-parallelizable steps
        -     b_p = []  # Parallelizable steps
        -     b_q = []  # Non-parallelizable steps
        -    for i in pla
        -      
        -      if i[1] in keys(c) && i[2] in keys(c)
        -         push!(b_p,i) # Add to parallelizable steps
        -      else
        -        push!(b_q,i) # Add to non-parallelizable steps
        -      end
        -     
        -     end
        -         # Combine the parallelizable and sequential steps
        -          l= length(b_p) # Number of parallelizable steps
        -          pla_p = append!(b_p,b_q)# Reordered plan
        -      # Return the reordered plan and the count of parallelizable steps
        -     return pla_p,l
        - end
        - 
        - 
        - 
        - """
        -     contrau_p(c_gn::TensorNetwork, pla_mf_p::Array{Tuple{Symbol, Symbol, Symbol}, 1}, p::Int)
        - 
        - Contracts the tensor network in the final phase of the algorithm, applying parallelism to the first `p` steps.
        - 
        - # Arguments
        - - `c_gn::TensorNetwork`: The tensor network to be contracted.
        - - `pla_mf_p::Array{Tuple{Symbol, Symbol, Symbol}, 1}`: The reordered contraction plan, where the first `p` elements are parallelizable.
        - - `p::Int`: The number of parallelizable contraction steps.
        - 
        - # Returns
        - - `Array{ComplexF64, 0}`: The storage of the final contracted tensor, representing the probability amplitude of a given input producing a given output.
        - 
        - # Notes
        - 1. The function uses parallel threads to process the first `p` contraction steps simultaneously.
        - 2. The remaining steps are processed sequentially.
        - 3. The storage of the final tensor in the contraction plan is returned as the result.
        - """
        - 
        -  
        - function contrau_p(c_gn::TensorNetwork, pla_mf_p::Vector{Any}, p::Int)
        -                   # Perform parallel contractions for the first `p` steps
        -                  @sync   Base.Threads.@threads for i in 1:p
        -                       
        -                       contract_pair!(c_gn, pla_mf_p[i][1],pla_mf_p[i][2],pla_mf_p[i][3])
        -                   end
        -                 # Perform sequential contractions for the remaining steps
        -                 for j in p+1:length(pla_mf_p)
        -                         contract_pair!(c_gn, pla_mf_p[j][1],pla_mf_p[j][2],pla_mf_p[j][3])
        -                   end
        -     return c_gn.tensor_map[pla_mf_p[end][3]].storage  # Return the value of the final contracted tensor
        -         end
        - 
        - 
        - """
        -     Calcul_GN_Sequencial(cct::Circuit, timings::Bool)
        - 
        - Performs a sequential contraction of a tensor network using a contraction plan generated by the GirvanâNewman (GN) algorithm.
        - 
        - # Arguments
        - - `cct::Circ`: The input quantum circuit to be evaluated.
        - - `timings::Bool`: If `true`, logs and prints timing information for each phase of the algorithm.
        - 
        - # Returns
        - - `Array{ComplexF64, 0}`: The result of the final contraction, representing the amplitude of a given input producing a given output.
        - 
        - # Notes
        - This function executes three main steps:
        - 1. Converts the circuit into a tensor network and generates a line graph.
        - 2. Creates a contraction plan using the GirvanâNewman algorithm.
        - 3. Performs the sequential contraction of the tensor network based on the generated plan.
        - """
        - 
        - using TimerOutputs
        - import QXZoo.Circuit.Circ
        - 
        - 
        - 
        - function Calcul_GN_Sequencial(cct::Circ,timings::Bool=true)
        - 
        -     # Reset timing information if enabled
        -   if timings
        -         reset_timer!()
        -     end
        -    
        -        
        -          # Step 1: Convert circuit to tensor network and generate its line graph
        -     @timeit "1T. Obtaining a line graph" begin
        -         tnc = convert_to_tnc(cct)  # Convert circuit to tensor network
        -         light_graf = convert_to_graph(tnc)  # Generate graph representation
        -         labeled_light_graf = LabeledGraph(light_graf)  # Create a labeled graph
        -         labeled_line_light_graf = line_graph_tris(labeled_light_graf)  # Generate line graph
        -     end
        - 
        -     # Step 2: Generate contraction plan using GirvanâNewman algorithm
        -     @timeit "2T. Getting GN plan" begin
        -         pla_gn = GN_pla(light_graf, tnc.tn)  # Generate contraction plan
        -     end
        -  
        -     
        -   # Step 3: Perform final contraction based on the GN plan
        -     @timeit "3T. Final contraction" begin
        -         s = contract_tn!(tnc.tn, pla_gn)  # Perform the contraction
        -     end
        - 
        -     # Print timing results if enabled
        -     if timings
        -         print_timer()
        -     end
        - 
        -     # Return the result of the final contraction
        -     return s
        - end
        - 
        - """
        -     ComParCPU(circ::Circ, entrada::Vector{Int}, eixida::Vector{Int}, n_com::Int; 
        -               timings::Bool=true, decompose::Bool=true)
        - 
        - Implements a three-phase tensor network contraction algorithm as described in the paper. 
        - 
        - # Arguments
        - - `circ::Circ`: The quantum circuit to evaluate.
        - - `entrada::String`: List of input qubits.
        - - `eixida::String`: List of output qubits.
        - - `n_com::Int`: Number of communities to explore.
        - - `timings::Bool=true`: If `true`, logs and prints timing results for each phase.
        - - `decompose::Bool=true`: If `true`, decomposes circuit gates into simpler gates.
        - 
        - # Returns
        - - `Array{ComplexF64, 0}`: The result of the final contraction, representing the amplitude of a given input producing a given output.
        - 
        - # Notes
        - The function consists of three main phases:
        - 1. Detect communities in the tensor network using the GirvanâNewman (GN) algorithm.
        - 2. Perform parallel contraction within each community.
        - 3. Perform the final sequential contraction using a min-fill plan.
        - """
        - 
        - using TimerOutputs
        - import QXZoo.Circuit.Circ
        - 
        - 
        0 function ComParCPU(circ::Circ, entrada::String, eixida::String, n_com::Int;timings::Bool=true, decompose::Bool=true)
        - 
        -      # Reset timing information if enabled
        0     if timings
        0         reset_timer!()
        -     end
        - 
        -           # Phase 1: Community detection and graph preparation
        - 
        0           @timeit "1T.Obtaining Communities" begin
        -                num_qubits = circ.num_qubits  
        -                # Convert circuit to tensor network
        -                tnc= convert_to_tnc(circ;no_input=false,no_output=false,input=entrada,output=eixida,decompose=true )                 
        -                # Convert tensor network to graph and generate its labeled version
        -                light_graf  = convert_to_graph(tnc)
        -                                
        -                labeled__light_graf=LabeledGraph(light_graf);
        -                  # Generate the line graph and convert to igraph
        -                labeled_line_light_graf= line_graph_tris(labeled__light_graf); 
        -    
        -                 h_Lg_ig=lg2ig(labeled__light_graf.graph);
        -                 h_Lg_ig.summary(verbosity=1);
        - 
        -                 #Detect communities using GirvanâNewman and compute modularity
        - 
        -                 comunitats_julia,comunitats_betwenness,modularitat=labelg_to_communitats_between(labeled__light_graf,n_com);
        -   
        -            end 
        -     
        -            # Phase 2: Parallel contraction within communities
        - 
        -     
        0             @timeit "2T.Parallel contraction of communities" begin
        -   
        -                     # Generate contraction plans and tensor networks for each community
        -                     tns,plans= pla_contraccio_multiple_G_N(comunitats_julia,tnc,light_graf)
        -                     # Perform the first parallel contraction phase
        -                     c =primera_contraccio_paral(tns,plans);
        -            
        -             end 
        -             
        -       
        -                 # Phase 3: Final sequential contraction
        0               @timeit "3T.Final Contraction" begin
        -               
        -                   # Generate min-fill plan and perform final contraction
        -               tw,pla= min_fill_contraction_plan_tw(c)
        -                
        -                 s=contract_tn!(c, pla)
        -                 
        -              end
        - 
        -         # Print timing results if enabled
        0          if timings
        0             print_timer()
        -         end
        - 
        -     # Return the result of the final contraction
        0     return s
        - end
        -         
        -         
        - 
        -     
        - 
        - """"
        -     ComParCPU_para(circ::Circ, entrada::String, eixida::String, n_com::Int; 
        -                    timings::Bool=true, decompose::Bool=true)
        - 
        - Implements a three-phase tensor network contraction algorithm with parallelism in the final contraction phase.
        - 
        - # Arguments
        - - `circ::Circ`: The quantum circuit to evaluate.
        - - `entrada::String`: List of input qubits.
        - - `eixida::String`: List of output qubits.
        - - `n_com::Int`: Number of communities to explore.
        - - `timings::Bool=true`: If `true`, logs and prints timing results for each phase.
        - - `decompose::Bool=true`: If `true`, decomposes circuit gates into simpler gates.
        - 
        - # Returns
        - - `Array{ComplexF64, 0}`: The result of the final contraction, representing the amplitude of a given input producing a given output.
        - 
        - # Notes
        - This function consists of three phases:
        - 1. Detect communities in the tensor network using the GirvanâNewman (GN) algorithm.
        - 2. Perform parallel contraction within each community.
        - 3. Perform the final contraction with parallelism applied to the initial steps of the contraction plan.
        - """
        - 
        - 
        - using TimerOutputs
        - import QXZoo.Circuit.Circ
        - 
        - 
        - function ComParCPU_para(circ::Circ, entrada::String, eixida::String,n_com::Int;timings::Bool=true, decompose::Bool=true)
        -          # Reset timing information if enabled
        -          if timings
        -             reset_timer!()
        -          end
        - 
        - 
        -           # Phase 1: Community detection and graph preparation
        -         @timeit "1T.Obtaining Communities" begin
        -                                
        -        
        - 
        -         # Convert circuit to tensor network
        -         tnc = convert_to_tnc(circ; no_input=false, no_output=false, input=entrada, output=eixida, decompose=decompose)
        - 
        -         # Convert tensor network to graph and generate its labeled version
        -         light_graf = convert_to_graph(tnc)
        -         labeled_light_graf = LabeledGraph(light_graf)
        - 
        -         # Generate the line graph and convert to igraph
        -         labeled_line_light_graf = line_graph_tris(labeled_light_graf)
        -         h_Lg_ig = lg2ig(labeled_light_graf.graph)
        -         h_Lg_ig.summary(verbosity=1)
        - 
        -         # Detect communities using GirvanâNewman and compute modularity
        -          comunitats_julia,comunitats_betwenness,modularitat=labelg_to_communitats_between(labeled_light_graf,n_com);
        -     end
        -         
        -                # Phase 2: Parallel contraction within communities
        -             @timeit "2T.Parallel contraction of communities" begin
        -                    # Generate contraction plans and tensor networks for each community  
        -                     tns,plans= pla_contraccio_multiple_G_N(comunitats_julia,tnc,light_graf)
        -                    # Perform the first parallel contraction phase
        -                     c =primera_contraccio_paral(tns,plans);
        -            
        -             end 
        -       
        -                    # Phase 3: Final contraction with parallelism
        -                     @timeit "3T.Final contraction in parallel" begin
        -                 
        -                          # Generate min-fill plan and parallelization details
        -                           tw,pla= min_fill_contraction_plan_tw(c)
        -                           pla_mf_p,p  = pla_paral_p(c,pla)
        -                           # Perform parallel and sequential contractions
        -                           s= contrau_p(c,pla_mf_p,p)
        -                     end
        -     # Print timing results if enabled
        -     if timings
        -             print_timer()
        -         end
        - # Return the result of the final contraction
        - return s
        - end
        - 
        - 
        - ################################
        - 
        - 
        - using TimerOutputs
        - import QXZoo.Circuit.Circ
        - 
        - 
        - """
        -     ComParCPU_GHZ(circ::Circ, entrada::String, eixida::String;timings::Bool=true, decompose::Bool=true)
        - 
        - Implements a three-phase tensor network contraction algorithm with parallelism in the final contraction phase.
        - 
        - # Arguments
        - - `circ::Circ`: The quantum circuit to evaluate.
        - - `entrada::String`: List of input qubits.
        - - `eixida::String`: List of output qubits.
        - - `timings::Bool=true`: If `true`, logs and prints timing results for each phase.
        - - `decompose::Bool=true`: If `true`, decomposes circuit gates into simpler gates.
        - 
        - # Returns
        - - `Array{ComplexF64, 0}`: The result of the final contraction, representing the amplitude of a given input producing a given output.
        - 
        - # Notes
        - This function consists of three phases:
        - 1. Detect communities in the tensor network using the Fast Greedy algorithm.
        - 2. Perform parallel contraction within each community.
        - 3. Perform the final contraction with parallelism applied to the initial steps of the contraction plan.
        - """
        - function ComParCPU_GHZ(circ::Circ, entrada::String, eixida::String;timings::Bool=true, decompose::Bool=true)
        -     # Reset timing information if enabled
        -     if timings
        -         reset_timer!()
        -     end
        - 
        -     # Phase 1: Community detection and graph preparation
        -     @timeit "1T.Obtaining Communities" begin
        -         num_qubits = circ.num_qubits
        -         tnc = convert_to_tnc(circ; no_input=false, no_output=false, input=entrada, output=eixida, decompose=true)
        - 
        -         # Convert tensor network to graph
        -         light_graf = convert_to_graph(tnc)
        - 
        -         # Generate labeled graph and line graph
        -         labeled__light_graf = LabeledGraph(light_graf)
        -         labeled_line_light_graf = line_graph_tris(labeled__light_graf)
        - 
        -         # Convert to igraph and summarize
        -         h_Lg_ig = lg2ig(labeled__light_graf.graph)
        -         h_Lg_ig.summary(verbosity=1)
        - 
        -         # Detect communities using Fast Greedy algorithm
        -         comunitats_julia, comunitats_betwenness, modularitat = labelg_to_communitats_fastgreedy(labeled__light_graf)
        -     end
        - 
        -     # Phase 2: Parallel contraction within communities
        -     @timeit "2T.Parallel contraction of communities" begin
        -         # Generate contraction plans and tensor networks for each community
        -         tns, plans = pla_contraccio_multiple_G_N(comunitats_julia, tnc, light_graf)
        -         
        -         # Perform the first parallel contraction phase
        -         c = primera_contraccio_paral(tns, plans)
        -     end
        - 
        -     # Phase 3: Final contraction with parallelism
        -     @timeit "3T.Final contraction" begin
        -         # Generate min-fill plan and perform final contraction
        -         tw, pla = min_fill_contraction_plan_tw(c)
        -         s = contract_tn!(c, pla)
        -     end
        - 
        -     # Print timing results if enabled
        -     if timings
        -         print_timer()
        -     end
        - 
        -     # Return the result of the final contraction
        -     return s
        - end
        - 
        - 
        - 
        - """
        -     ComParCPU_para_GHZ(circ::Circ, entrada::String, eixida::String, n_com::Int; 
        -                    timings::Bool=true, decompose::Bool=true)
        - 
        - Implements a three-phase tensor network contraction algorithm with parallelism in the final contraction phase.
        - 
        - # Arguments
        - - `circ::Circ`: The quantum circuit to evaluate.
        - - `entrada::String`: List of input qubits.
        - - `eixida::String{Int}`: List of output qubits.
        - - `n_com::Int`: Number of communities to explore.
        - - `timings::Bool=true`: If `true`, logs and prints timing results for each phase.
        - - `decompose::Bool=true`: If `true`, decomposes circuit gates into simpler gates.
        - 
        - # Returns
        - - `Array{ComplexF64, 0}`: The result of the final contraction, representing the amplitude of a given input producing a given output.
        - 
        - # Notes
        - This function consists of three phases:
        - 1. Detect communities in the tensor network using the GirvanâNewman (GN) algorithm.
        - 2. Perform parallel contraction within each community.
        - 3. Perform the final contraction with parallelism applied to the initial steps of the contraction plan.
        - """
        - function ComParCPU_para_GHZ(circ::Circ, entrada::String, eixida::String;timings::Bool=true, decompose::Bool=true)
        -     # Reset timing information if enabled
        -     if timings
        -         reset_timer!()
        -     end
        - 
        -     # Phase 1: Community detection and graph preparation
        -     @timeit "1T.Obtaining Communities" begin
        -         # Convert circuit to tensor network
        -         tnc = convert_to_tnc(circ; no_input=false, no_output=false, input=entrada, output=eixida, decompose=decompose)
        - 
        -         # Convert tensor network to graph and generate its labeled version
        -         light_graf = convert_to_graph(tnc)
        -         labeled_light_graf = LabeledGraph(light_graf)
        - 
        -         # Generate the line graph and convert to igraph
        -         labeled_line_light_graf = line_graph_tris(labeled_light_graf)
        -         h_Lg_ig = lg2ig(labeled_light_graf.graph)
        -         h_Lg_ig.summary(verbosity=1)
        - 
        -         # Detect communities using Fast Greedy and compute modularity
        -          comunitats_julia, comunitats_betwenness, modularitat = labelg_to_communitats_fastgreedy(labeled_light_graf)
        -     end
        - 
        -     # Phase 2: Parallel contraction within communities
        -     @timeit "2T.Parallel contraction of communities" begin
        -         # Generate contraction plans and tensor networks for each community
        -         tns, plans = pla_contraccio_multiple_G_N(comunitats_julia, tnc, light_graf)
        -         
        -         # Perform the first parallel contraction phase
        -         c = primera_contraccio_paral(tns, plans)
        -     end
        - 
        -     # Phase 3: Final contraction with parallelism
        -     @timeit "3T.Final contraction in parallel" begin
        -         # Generate min-fill plan and parallelization details
        -         tw, pla = min_fill_contraction_plan_tw(c)
        -         pla_mf_p, p = pla_paral_p(c, pla)
        -         
        -         # Perform parallel and sequential contractions
        -         s = contrau_p(c, pla_mf_p, p)
        -     end
        - 
        -     # Print timing results if enabled
        -     if timings
        -         print_timer()
        -     end
        - 
        -     # Return the result of the final contraction
        -     return s
        - end
