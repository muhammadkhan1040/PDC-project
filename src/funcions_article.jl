
#### Funcions necessaries per a l'article exclúsivament ############

import LightGraphs as lg
using LinearAlgebra
using Base.Threads
import LightGraphs as lg
using Base.GC

# These appear to be custom modules/packages based on the function names
using QXGraphDecompositions  # For functions like add_edge! and combine_labels
# You'll need the module that defines these types:
# TensorNetwork, TensorNetworkCircuit, QXTensor, LabeledGraph

# If these are custom modules in your project, you may need something like:
# include("tensor_network.jl")
# include("labeled_graph.jl")

"""
    create_qft_circuit_bis(n::Integer)

Creates a Quantum Fourier Transform (QFT) circuit with `n` qubits.

# Arguments
- `n::Integer`: The number of qubits in the circuit.

# Returns
- `Circ`: A QFT circuit object with the specified number of qubits.

# Notes
This function initializes a QFT circuit and applies controlled-X gates as part of its structure.
"""
function create_qft_circuit_bis(n::Integer)
    circ = QXZoo.Circuit.Circ(n)
    QXZoo.QFT.apply_qft!(circ, collect(1:n))
    QXZoo.Circuit.add_gatecall!(circ, QXZoo.DefaultGates.c_x(1, 2))
    QXZoo.Circuit.add_gatecall!(circ, QXZoo.DefaultGates.c_x(2, 3))
    circ
end

function line_graph_tris(G::LabeledGraph)
    # Call the AbstractGraph version, passing the graph and its labels
    return line_graph_tris(G.graph, vertex_labels=G.labels)
end

# **************************************************************************************** #
#                          Functions for creating various graphs
# **************************************************************************************** #

"""
    line_graph_tris(G::LabeledGraph)

Creates the line graph of the input labeled graph `G`.

# Arguments
- `G::LabeledGraph`: The input labeled graph.

# Returns
- `LabeledGraph`: A line graph where each vertex represents an edge in the original graph.
  The label for each vertex in the line graph is generated by concatenating the labels of
  the vertices connected by the corresponding edge in the input graph.

# Notes
The function orders the vertex labels of each edge to ensure consistent labeling.
"""
function line_graph_tris(G::lg.AbstractGraph; 
                    vertex_labels::Array{Symbol, 1}=Symbol[])
    # Create a labeled graph LG whose vertices corresponding to the edges of G.
    G_edges = collect(lg.edges(G))
    
    if isempty(vertex_labels)
        # Pre-allocate vertex_labels for better memory efficiency
        vertex_labels = Vector{Symbol}(undef, length(G_edges))
        
        # Use SIMD-friendly loop
        @inbounds for (idx, e) in enumerate(G_edges)
            if e.src < e.dst
                vertex_labels[idx] = Symbol(G.labels[e.src], :_, G.labels[e.dst])
            else
                vertex_labels[idx] = Symbol(G.labels[e.dst], :_, G.labels[e.src])
            end
        end
    end
    
    LG = LabeledGraph(lg.SimpleGraph(length(G_edges)), vertex_labels)

    # Optimize the nested loop with edge connections
    # This is a hotspot for optimization
    @inbounds for i in 1:length(G_edges)-1
        u = G_edges[i]
        u_src, u_dst = u.src, u.dst
        
        for j in i+1:length(G_edges)
            v = G_edges[j]
            v_src, v_dst = v.src, v.dst
            
            if (u_src == v_src) || (u_src == v_dst) || (u_dst == v_src) || (u_dst == v_dst)
                QXGraphDecompositions.add_edge!(LG, i, j)
            end
        end
    end
    
    return LG
end



# Add OpenMP support to Julia
using LinearAlgebra
BLAS.set_num_threads(Sys.CPU_THREADS)

# Make sure we're using the fastest BLAS implementation
LinearAlgebra.BLAS.vendor()

# Set environment variable for OpenMP
ENV["JULIA_NUM_THREADS"] = string(Sys.CPU_THREADS)

# Configure memory allocation to be more efficient
# Reduces GC overhead for large tensor operations
using Base.GC
GC.enable_logging(false)

"""
    line_graph_tris(G::lg.AbstractGraph; vertex_labels::Array{Symbol, 1}=Symbol[])

Creates the line graph of the input abstract graph `G`.

# Arguments
- `G::lg.AbstractGraph`: The input abstract graph.
- `vertex_labels::Array{Symbol, 1}=Symbol[]`: An optional array of symbols used as vertex labels.
  If left empty, labels are generated by concatenating the indices of the corresponding vertices in `G`.

# Returns
- `LabeledGraph`: A labeled graph where:
  - Each vertex represents an edge in the input graph.
  - Edges are added between vertices in the line graph if the corresponding edges in the input graph share a vertex.

# Notes
If no custom `vertex_labels` are provided, the function generates them by combining the indices of the vertices connected by each edge in the input graph.
"""
function line_graph_tris(G::lg.AbstractGraph; 
                    vertex_labels::Array{Symbol, 1}=Symbol[])
    # Create a labeled graph LG whose vertices corresponding to the edges of G.
    
    G_edges = collect(lg.edges(G))
    if isempty(vertex_labels)
        #vertex_labels = [QXGraphDecompositions.combine_labels(e.src, e.dst) for e in G_edges]
        #vertex_labels=[]
        for e in G_edges
            if e.src < e.dst
                etiqueta=Symbol(G.labels[e.src], :_, G.labels[e.dst])
                push!(vertex_labels,etiqueta)
                
            else
                etiqueta=Symbol(G.labels[e.dst], :_, G.labels[e.src])
                push!(vertex_labels,etiqueta)
            end
        end
    end
    LG = LabeledGraph(lg.SimpleGraph(length(G_edges)), vertex_labels)

    # Connect any two vertices of LG whose corresponding edges in G share a vertex in G.
    for i in 1:length(G_edges)-1
        for j in i+1:length(G_edges)
            u = G_edges[i]
            v = G_edges[j]
            if (u.src == v.src) || (u.src == v.dst) || (u.dst == v.src) || (u.dst == v.dst)
                QXGraphDecompositions.add_edge!(LG, i, j)
            end
        end
    end
    LG
end


"""
    GN_pla(g::AbstractGraph, tnc_tn::TensorNetwork)

Generates a contraction plan for a tensor network based on the Girvan-Newman (GN) algorithm.

# Arguments
- `g::AbstractGraph`: The input abstract graph.
- `tnc_tn::TensorNetwork`: The tensor network to be contracted.

# Returns
- `Array{Tuple{Symbol, Symbol, Symbol}, 1}`: A contraction plan represented as an ordered list of pairs of tensors to contract.

# Notes
This function uses the Girvan-Newman algorithm to detect communities in the graph, which are then converted into a contraction plan for the tensor network.
"""

 
function GN_pla(g::AbstractGraph, tnc_tn::TensorNetwork)::Array{Tuple{Symbol, Symbol, Symbol}, 1}
        
     h_ig=lg2ig(g) 

     comunitat=ordenacio_girvan_igraph(h_ig)
     
     ordenacio=Vector{Symbol}[]
     for i in comunitat
        parella=[]
    
        tensor_1= Symbol("t"*(string(i[1])))
        tensor_2= Symbol("t"*(repr(i[2]))) 
        push!(parella,tensor_1,tensor_2)
        push!(ordenacio,parella)
     end
      
        pla=order_to_contraction_plan(ordenacio,tnc_tn)
  end


"""
    GN_pla(g::AbstractGraph, vmap::Array{Int64, 1}, tnc_tn::TensorNetwork)

Generates a contraction plan for a tensor network based on the Girvan-Newman (GN) algorithm,
using a vertex mapping.

# Arguments
- `G::AbstractGraph`: The input abstract graph.
- `vmap::Array{Int64, 1}`: using as a mapping of vertex indices to symbolic tensor names.
- `tnc_tn::TensorNetwork`: The tensor network to be contracted.

# Returns
- `Array{Tuple{Symbol, Symbol, Symbol}, 1}`: A contraction plan represented as an ordered list of pairs of tensors to contract.  A contraction plan for the tensor network.
# Notes
This version of the function uses the vertex mapping `vmap` to resolve symbolic names for the tensors in the contraction plan.
"""


function  GN_pla(g::AbstractGraph, vmap::Array{Int64, 1}, tnc_tn::TensorNetwork)
        
     # Convert the input graph into its Python igraph representation
    h_ig = lg2ig(g)

    # Perform community detection using the Girvan-Newman algorithm
    comunitat = ordenacio_girvan_igraph(h_ig)

    # Generate a contraction order based on the community structure and vertex mapping
    ordenacio = Vector{Symbol}[]
    for i in comunitat
        parella = []

        tensor_1 = Symbol("t" * string(vmap[i[1]]))
        tensor_2 = Symbol("t" * repr(vmap[i[2]]))
        push!(parella, tensor_1, tensor_2)
        push!(ordenacio, parella)
    end

    # Convert the contraction order into a contraction plan
     pla=order_to_contraction_plan(ordenacio,tnc_tn)
    
      
    
  end


    





# **************************************************************************************** #
#       Converting edge elimination orders & contraction trees into contraction plans
# **************************************************************************************** #


"""
    order_to_contraction_plan(elimination_order::Array{<:Array{Symbol, 1}, 1},
                              tn::Union{TensorNetwork, OrderedDict{Symbol, Array{Index, 1}}}
                              )::Array{NTuple{3, Symbol}, 1}

Converts an edge elimination order into a contraction plan for the input tensor network.

# Arguments
- `elimination_order::Array{Array{Symbol, 1}, 1}`: The order in which tensor edges should be eliminated,
  represented as an array of symbol arrays.
- `tn::Union{TensorNetwork, OrderedDict{Symbol, Array{Index, 1}}}`: The tensor network or its dictionary
  representation. If a dictionary is provided, keys are tensor IDs and values are arrays of indices associated
  with each tensor.

# Returns
- `Array{NTuple{3, Symbol}, 1}`: A contraction plan, where each tuple `(A_id, B_id, I_id)` represents:
  - `A_id` and `B_id`: IDs of tensors being contracted.
  - `I_id`: ID of the resulting intermediate tensor.

# Notes
This function generates a sequence of tensor contractions based on an elimination order. Intermediate tensors
are created dynamically during the process, and their mapping is updated iteratively.
"""

function order_to_contraction_plan(elimination_order::Array{Array{Symbol, 1}, 1},
                                   tn::Union{TensorNetwork, OrderedDict{Symbol, Array{Index, 1}}}
                                   )::Array{NTuple{3, Symbol}, 1}
    # An array to hold the contraction plan.
    plan = Array{NTuple{3, Symbol}, 1}()

    # A dictionary to keep track of which tensors are replaced by which intermediate tensors
    # at different stages of the contraction process. Initially, before any pairwise
    # contractions, none of the tensors are replaced by intermediates, so all tensor ids are
    # mapped to themselves.
    intermediate_tensor_map = Dict{Symbol, Symbol}(keys(tn) .=> keys(tn))

    # Convert each edge in the elimination order to a set of pairwise contractions and
    # append it to plan.
    for (i, edge) in enumerate(elimination_order)
        if length(edge) == 2
            # For edges consisting of just two tensors, find the intermediates they belong
            # to and add their pairwise contraction to the plan.
            A_id = _get_intermediate_tensor(intermediate_tensor_map, edge[1])
            B_id = _get_intermediate_tensor(intermediate_tensor_map, edge[2])
            if !(A_id == B_id)
                # id for the new intermediate created by contracting A_id and B_id.
                I_id = Symbol("I$i")
                append!(plan, [(A_id, B_id, I_id)])

                # Update intermediate_tensor_map with new intermediate.
                intermediate_tensor_map[A_id] = I_id
                intermediate_tensor_map[B_id] = I_id
                intermediate_tensor_map[I_id] = I_id
            end

        elseif length(edge) > 2
            # For edges with more than 2 tensors, collect all of the tensors and
            # intermediate tensors that belong to the edge and find a contraction plan for
            # them. Append the contraction this plan to plan.
            tensors_to_contract = OrderedDict{Symbol, Array{Index, 1}}()
            for t_id in edge
                I_id = _get_intermediate_tensor(intermediate_tensor_map, t_id)
                inds = typeof(tn) <: TensorNetwork ? QXTns.inds(tn[t_id]) : tn[t_id]
                tensors_to_contract[I_id] = symdiff(get(tensors_to_contract, I_id, []), inds)
            end
            if length(tensors_to_contract) > 1
                # Check if netcon can be used on the given set of tensors. If not, use
                # a fallback method to find a contraction plan.
                tensor_sizes = prod.([QXTns.dim.(inds) for inds in values(tensors_to_contract)])
                if length(tensors_to_contract) < 37 && any(tensor_sizes .< 2^62)
                    local_contraction_plan = netcon(tn, tensors_to_contract)
                else
                    local_contraction_plan = min_fill_contraction_plan(tensors_to_contract)
                end
                append!(plan, local_contraction_plan)

                # Update intermediate_tensor_map with new intermediates.
                for (A_id, B_id, I_id) in local_contraction_plan
                    intermediate_tensor_map[A_id] = I_id
                    intermediate_tensor_map[B_id] = I_id
                    intermediate_tensor_map[I_id] = I_id
                end
            end
        end
    end
    plan
end




"""
    _get_intermediate_tensor(intermediate_tensor_map::Dict{Symbol, Symbol}, t_id::Symbol)::Symbol

Retrieves the ID of the intermediate tensor associated with the given tensor `t_id`.

# Arguments
- `intermediate_tensor_map::Dict{Symbol, Symbol}`: A mapping that tracks which tensors have been replaced
  by intermediate tensors during the contraction process.
- `t_id::Symbol`: The ID of the tensor for which the intermediate tensor is being queried.

# Returns
- `Symbol`: The ID of the intermediate tensor that represents the final state of `t_id`. 
  If `t_id` has not been replaced, it returns `t_id` itself.

# Notes
The function iteratively traverses the `intermediate_tensor_map` to find the final intermediate tensor
associated with the input `t_id`. It stops when the tensor ID maps to itself, indicating that it has
not yet been replaced.
"""
function _get_intermediate_tensor(intermediate_tensor_map::Dict{Symbol, Symbol}, t_id::Symbol)::Symbol
    while true
        I_id = intermediate_tensor_map[t_id]
        # If t_id = I_id then t_id has not been replaced by an intermediate tensor yet.
        (t_id == I_id) && return I_id
        t_id = I_id
    end
end



"""
    lg2ig(lg_g::AbstractGraph)::igraph.Graph

Converts a Julia `AbstractGraph` into a Python `igraph.Graph`.

# Arguments
- `lg_g::AbstractGraph`: The input graph in Julia.

# Returns
- `igraph.Graph`: A Python `igraph` representation of the input graph as a  PyObject

# Notes
1. This function ensures compatibility between Julia's `AbstractGraph` and Python's `igraph`.
2. Julia's 1-based indexing is adjusted to Python's 0-based indexing.
3. For more details on the Python `igraph` library, visit: https://python.igraph.org/en/latest/index.html
"""
ig = pyimport("igraph");


function lg2ig(lg_g::AbstractGraph)
    # Initialize a Python igraph Graph with the same number of vertices as the input graph
    i_g = ig.Graph(LightGraphs.nv(lg_g))

    # Collect edges from the input graph and adjust indices for Python's 0-based indexing
    arestes = []
    for e in LightGraphs.edges(lg_g)
        a=(LightGraphs.src(e)-1,LightGraphs.dst(e)-1)
        push!(arestes, a)
    end

    # Add edges to the Python igraph Graph
    i_g.add_edges(arestes)

    # Return the constructed igraph Graph as a PyObject 
    return i_g
end



"""
    ordenacio_girvan_igraph(h::PyObject)::Vector{Tuple{Int, Int}}

Applies the Girvan-Newman (GN) algorithm to a Python `igraph.Graph` and returns an edge elimination order.

# Arguments
- `h::PyObject`: A Python `igraph.Graph` object. 

# Returns
- `Vector{Tuple{Int, Int}}`: A reversed list of edges (as pairs of vertex indices) ordered by their removal in the GN algorithm.

# Notes
1. The Girvan-Newman algorithm iteratively removes edges with the highest betweenness centrality to identify community structures.
2. This function generates an ordered list of edge removals based on the algorithm.
3. Vertex indices are converted from Python's 0-based indexing to Julia's 1-based indexing for compatibility.

# See Also
For more details on `igraph` and the Girvan-Newman algorithm, visit: https://python.igraph.org/en/latest/index.html
"""


function ordenacio_girvan_igraph(h)
    # Initialize an empty list to store the order of edge removals
    eixida = []

    # Iteratively remove edges based on edge betweenness
    for _ in 1:length(h.get_edgelist())
        # Compute edge betweenness values
        edge_betweenness = h.edge_betweenness()

        # Find the edge with the maximum betweenness
        aresta = findmax(edge_betweenness)[2]
        e = h.es[aresta]
        edge = e.source+1, e.target+1   # Convert indices to 1-based

        # Append the edge to the elimination order
        push!(eixida, edge)

        # Remove the edge from the graph
        id = h.get_eid(e.source, e.target)
        h.delete_edges(id)
    end

    # Reverse the order of eliminations to reflect final removal order
    eixida_inv = reverse(eixida)

    # Return the reversed edge elimination order
    return eixida_inv
end




"""
    labelg_to_communitats_between(labeled_light_graf::LabeledGraph, clusters::Int)

Identifies communities in a labeled graph using edge betweenness and computes their modularity.

# Arguments
- `labeled_light_graf::LabeledGraph`: The input labeled graph.
- `clusters::Int`: The number of clusters to detect. If set to `0`, the algorithm automatically determines the number of clusters.

# Returns
- `Vector{Vector{Int}}`: A Julia-style representation of communities, where each community is a vector of vertex indices.
- `Array{Array{Int64, 1}, 1}`: A Python-style representation of communities.
- `Float64`: The modularity score of the detected community structure.

# Notes
1. The function uses the `community_edge_betweenness` method from the Python `igraph` library to detect communities.
2. Vertex indices are converted from Python's 0-based indexing to Julia's 1-based indexing.
3. The modularity score measures the quality of the detected community structure.

# See Also
For more information on `igraph` and community detection, visit: https://python.igraph.org/en/latest/index.html
"""


function labelg_to_communitats_between(labeled__light_graf::LabeledGraph,clusters::Int)
        # Convert the labeled graph to a Python igraph representation
        h_Lg_ig=lg2ig(labeled__light_graf.graph);
        # Perform community detection using edge betweenness
        if clusters==0
            communities_Lg =h_Lg_ig.community_edge_betweenness( ) 
        else
            communities_Lg =h_Lg_ig.community_edge_betweenness(clusters=clusters) 
        end
        # Convert the detected communities into a clustering
        communities_Lg = communities_Lg.as_clustering();
        # Convert Python-style communities to Julia-style
        comunitats_betwenness=py"""list"""(communities_Lg);
        comunitats_julia=[];
    
        for i in comunitats_betwenness
            planet=Int[]
            for j in 1:length(i)
            push!(planet,i[j]+1) # Adjust to 1-based indexing
            end
        push!(comunitats_julia,planet)
        end
        # Compute the modularity of the detected communities
        modularitat=h_Lg_ig.modularity(communities_Lg) 
      # Return the Julia-style communities, Python-style communities, and modularity
    return comunitats_julia,comunitats_betwenness,modularitat
end


"""
    labelg_to_communitats_fastgreedy(labeled__light_graf::LabeledGraph)

Detects communities in a labeled graph using the Fast Greedy algorithm and computes the modularity of the detected community structure.

# Arguments
- `labeled__light_graf::LabeledGraph`: The labeled graph to analyze.

# Returns
- `Array{Array{Int64, 1}, 1}`: A Julia-style representation of communities.
- `Array{Array{Int64, 1}, 1}`: A Python-style representation of communities.
- `Float64`: The modularity score of the detected community structure.

# Notes
1. The function uses the `community_fastgreedy` method from the Python `igraph` library to detect communities.
2. Vertex indices are converted from Python's 0-based indexing to Julia's 1-based indexing.
3. The modularity score measures the quality of the detected community structure.
"""
function labelg_to_communitats_fastgreedy(labeled__light_graf::LabeledGraph)
    # Convert labeled graph to igraph format
    h_Lg_ig = lg2ig(labeled__light_graf.graph)
    
    # Detect communities using the Fast Greedy algorithm
    communities_Lg = h_Lg_ig.community_fastgreedy() # Obtain optimal communities based on modularity
    
    # Convert the detected communities to clustering format
    communities_Lg = communities_Lg.as_clustering()
    
    # Convert the communities to a Python list
    comunitats_betwenness = py"""list"""(communities_Lg)
    
    # Initialize an empty array to store the communities in Julia format
    comunitats_julia = []
    
    # Convert community indices from Python's 0-based indexing to Julia's 1-based indexing
    for i in comunitats_betwenness
        planet = Int[]
        for j in 1:length(i)
            push!(planet, i[j] + 1)
        end
        push!(comunitats_julia, planet)
    end
    
    # Compute the modularity of the detected community structure
    modularitat = h_Lg_ig.modularity(communities_Lg)
    
    # Return the communities in Julia format, Python format, and the modularity score
    return comunitats_julia, comunitats_betwenness, modularitat
end



"""
    pla_contraccio_multiple_G_N(nova_llista_comunitats_julia::Array{Any, 1}, 
                                tnc::TensorNetworkCircuit, 
                                g::AbstractGraph)

Generates contraction plans and tensor networks for each community in a list of communities.

# Arguments
- `nova_llista_comunitats_julia::Array{Any, 1}`: A list of communities, where each community is represented as a vector of vertex indices.
- `tnc::TensorNetworkCircuit`: The tensor network circuit containing the tensor mappings.
- `g::AbstractGraph`: The input graph representing the full tensor network.

# Returns
- `Vector{TensorNetwork}`: A list of tensor networks, one for each community.
- `Vector{Array}`: A list of contraction plans, one for each community.

# Notes
1. For each community, a contraction plan is generated using the Girvan-Newman algorithm.
2. Tensor networks are created for each community by mapping the community nodes to their respective tensors.
3. The function organizes the communities into independent tensor networks for parallel or individual processing.
"""



import QXGraphDecompositions

function pla_contraccio_multiple_G_N(nova_llista_comunitats_julia::Array{Any, 1}, tnc::TensorNetworkCircuit, g::AbstractGraph)
    n_communities = length(nova_llista_comunitats_julia)
    
    # Pre-allocate arrays for better memory efficiency
    plans = Vector{Any}(undef, n_communities)
    comunitats_x = Vector{Any}(undef, n_communities)
    tns = Vector{Any}(undef, n_communities)
    
    # Generate contraction plans for each community - this can be parallelized
    @inbounds Threads.@threads for i in 1:n_communities
        subgraf = nova_llista_comunitats_julia[i]
        sg, vmap = LightGraphs.induced_subgraph(g, subgraf)
        vmap_s = Symbol.(vmap)
        plans[i] = GN_pla(sg, vmap, tnc.tn)
        
        # Process community tensors in the same thread to avoid race conditions
        comunitat = [Symbol("t$j") for j in nova_llista_comunitats_julia[i]]
        comunitats_x[i] = comunitat
        
        # Create tensor network for this community
        tensors_c = Vector{QXTensor}(undef, length(comunitat))
        for (idx, tensor_sym) in enumerate(comunitat)
            tensors_c[idx] = tnc.tn.tensor_map[tensor_sym]
        end
        
        tns[i] = TensorNetwork(tensors_c, comunitat)
    end
    
    return tns, plans
end


"""
    TensorNetwork(array::Vector{<:QXTensor}, comunitat::Vector{Symbol})

Creates a tensor network object (subnetwork) from an array of tensors and a corresponding array of symbolic names.

# Arguments
- `array::Vector{<:QXTensor}`: An array of tensors, each represented as a `QXTensor` object.
- `comunitat::Vector{Symbol}`: An array of symbolic names representing the tensors in the network.

# Returns
- `TensorNetwork`: A new tensor network object containing:
  - `tensor_map`: A mapping of symbolic tensor names to their corresponding tensors.
  - `bond_map`: A mapping of bonds to the tensors they connect.
  - `next_id`: The ID for the next intermediate tensor.

# Notes
1. The function maps each tensor in the `array` to a unique symbolic name provided in `comunitat`.
2. It constructs a bond map to track which tensors are connected via shared bonds, facilitating efficient contraction.
"""



using ITensors
using LinearAlgebra
using NDTensors


function TensorNetwork(array::Vector{<: QXTensor},comunitat::Vector{Symbol})
     # Initialize the tensor map and bond map
    tensor_map = OrderedDict{Symbol, QXTensor}()
    bond_map = OrderedDict{Index, Vector{Symbol}}()
    # ID counter for intermediate tensors
    next_id = 1
    # Populate the tensor map and bond map
    for t in array
        tensor_id = Symbol(comunitat[next_id])
        next_id += 1
        tensor_map[tensor_id] = t
        for bond in inds(t)
            if haskey(bond_map, bond)
                push!(bond_map[bond], tensor_id)
            else
                bond_map[bond] = [tensor_id]
            end
        end
    end
     # Return the constructed tensor network
    TensorNetwork(tensor_map, bond_map, next_id)
end


"""
    primera_contraccio_paral(tns::Vector{TensorNetwork}, plans::Vector{Array{Tuple{Symbol, Symbol, Symbol}, 1}}})

Performs the first parallel contraction phase, merging multiple tensor networks into a single unified network.

# Arguments
- `tns::Vector{TensorNetwork}`: A vector of tensor networks, one for each community.
- `plans::Vector{Array{Tuple{Symbol, Symbol, Symbol}, 1}}}`: A vector of contraction plans, where each plan corresponds to a tensor network in `tns`.

# Returns
- `TensorNetwork`: A single tensor network resulting from the contraction and merging of all input networks.

# Notes
1. The function first applies parallel contraction to each tensor network using the provided plans.
2. After parallel contraction, all tensor networks are merged into a single unified network.
"""


function primera_contraccio_paral(tns::Vector{Any},plans::Vector{Any})
    # Perform parallel contraction on each tensor network using the respective plans
    contraccio_paral(tns, plans)
    # Initialize an empty tensor network to hold the merged result
    c=TensorNetwork() 
    # Merge all contracted tensor networks into the unified network
    for i in 1: length(tns)
   
          c=Base.merge(c, tns[i])
    end
    # Return the unified tensor network
    return c 
   
end


"""
    contraccio_paral(tns::Vector{TensorNetwork}, plans::Vector{Array{Tuple{Symbol, Symbol, Symbol}, 1}})

Performs parallel contraction of tensor networks using the provided contraction plans.

# Arguments
- `tns::Vector{TensorNetwork}`: A vector of tensor networks to be contracted.
- `plans::Vector{Array{Tuple{Symbol, Symbol, Symbol}, 1}}`: A vector of contraction plans, where each plan corresponds to a tensor network in `tns`.

# Returns
- `Vector{TensorNetwork}`: The vector of tensor networks after applying the contractions.

# Notes
1. This function uses multithreading (`Base.Threads.@threads`) to contract multiple tensor networks in parallel.
2. Each tensor network in `tns` is contracted independently according to its corresponding contraction plan in `plans`.
3. The `@sync` ensures that all parallel tasks are completed before proceeding.
"""

using DataStructures
using Distributed

function contraccio_paral(tns::Vector{Any}, plans::Vector{Any})
    # Using OpenMP for parallelization
    @inbounds @simd for i in 1:length(tns)
        contract_tn!(tns[i], plans[i])
    end
    return tns
end

"""
    min_fill_contraction_plan_tw(tn::TensorNetwork; hypergraph::Bool=false)

Generates a contraction plan and computes the treewidth for the input tensor network using the min-fill heuristic.

# Arguments
- `tn::TensorNetwork`: The input tensor network for which the contraction plan is generated.
- `hypergraph::Bool=false`: If `true`, considers hyperedges when constructing the line graph.

# Returns
- `Int`: The treewidth of the tensor network.
- `Array{Tuple{Symbol, Symbol, Symbol}, 1}`: A contraction plan for the tensor network.

# Notes
1. The function converts the tensor network into a line graph representation.
2. It uses the min-fill heuristic from `QXGraphDecompositions` to compute the treewidth and generate an elimination order.
3. The elimination order is converted into a contraction plan.
4. This function is essential for efficient contraction planning in tensor networks.
"""



import QXGraphDecompositions as qxg
import LightGraphs

function min_fill_contraction_plan_tw(tn::TensorNetwork;hypergraph::Bool=false)
    # Convert tn to a line graph and pass it to flow cutter to find an tree decomposition.
    lg, symbol_map = convert_to_line_graph(tn, use_hyperedges=hypergraph)

    # Use flow cutter to try find a tree decomposition of the line graph.
    tw, order = qxg.min_fill(lg)

    # Convert the elimination order to an array of Index structs in tn.
    order = [symbol_map[lg_vertex] for lg_vertex in order]

    # Convert the elimination order into a contraction plan.
    pla = order_to_contraction_plan(order, tn)
    return tw,pla 
end

min_fill_contraction_plan_tw(tnc::TensorNetworkCircuit; kwargs...) = min_fill_contraction_plan_tw(tnc.tn; kwargs...)


"""
    pla_paral_p(c::TensorNetwork, pla::Array{Tuple{Symbol, Symbol, Symbol}, 1})

Reorganizes a contraction plan into parallelizable and sequential elements.

# Arguments
- `c::TensorNetwork`: The unified tensor network after the first parallel contraction phase.
- `pla::Array{Tuple{Symbol, Symbol, Symbol}, 1}`: The sequential contraction plan, which could be generated using algorithms like min-fill or FlowCutter.

# Returns
- `Array{Tuple{Symbol, Symbol, Symbol}, 1}`: A reordered contraction plan with parallelizable elements first, followed by the remaining sequential elements.
- `Int`: The number of parallelizable elements in the contraction plan.

# Notes
1. The function separates the contraction steps into parallelizable and non-parallelizable categories.
2. Parallelizable steps are those whose tensors exist in the keys of the tensor network `c`.
3. The output plan starts with parallelizable elements followed by sequential ones.
"""



function pla_paral_p(c::TensorNetwork,pla::Array{Tuple{Symbol, Symbol, Symbol}, 1})
    # Lists to store parallelizable and non-parallelizable steps
    b_p = []  # Parallelizable steps
    b_q = []  # Non-parallelizable steps
   for i in pla
     
     if i[1] in keys(c) && i[2] in keys(c)
        push!(b_p,i) # Add to parallelizable steps
     else
       push!(b_q,i) # Add to non-parallelizable steps
     end
    
    end
        # Combine the parallelizable and sequential steps
         l= length(b_p) # Number of parallelizable steps
         pla_p = append!(b_p,b_q)# Reordered plan
     # Return the reordered plan and the count of parallelizable steps
    return pla_p,l
end



"""
    contrau_p(c_gn::TensorNetwork, pla_mf_p::Array{Tuple{Symbol, Symbol, Symbol}, 1}, p::Int)

Contracts the tensor network in the final phase of the algorithm, applying parallelism to the first `p` steps.

# Arguments
- `c_gn::TensorNetwork`: The tensor network to be contracted.
- `pla_mf_p::Array{Tuple{Symbol, Symbol, Symbol}, 1}`: The reordered contraction plan, where the first `p` elements are parallelizable.
- `p::Int`: The number of parallelizable contraction steps.

# Returns
- `Array{ComplexF64, 0}`: The storage of the final contracted tensor, representing the probability amplitude of a given input producing a given output.

# Notes
1. The function uses parallel threads to process the first `p` contraction steps simultaneously.
2. The remaining steps are processed sequentially.
3. The storage of the final tensor in the contraction plan is returned as the result.
"""

 
function contrau_p(c_gn::TensorNetwork, pla_mf_p::Vector{Any}, p::Int)
    # Using OpenMP for the parallelizable sections
    @inbounds Threads.@threads for i in 1:p
        contract_pair!(c_gn, pla_mf_p[i][1], pla_mf_p[i][2], pla_mf_p[i][3])
    end
    
    # Use SIMD for sequential part to optimize memory access patterns
    @inbounds for j in p+1:length(pla_mf_p)
        contract_pair!(c_gn, pla_mf_p[j][1], pla_mf_p[j][2], pla_mf_p[j][3])
    end
    
    return c_gn.tensor_map[pla_mf_p[end][3]].storage
end


"""
    Calcul_GN_Sequencial(cct::Circuit, timings::Bool)

Performs a sequential contraction of a tensor network using a contraction plan generated by the Girvan–Newman (GN) algorithm.

# Arguments
- `cct::Circ`: The input quantum circuit to be evaluated.
- `timings::Bool`: If `true`, logs and prints timing information for each phase of the algorithm.

# Returns
- `Array{ComplexF64, 0}`: The result of the final contraction, representing the amplitude of a given input producing a given output.

# Notes
This function executes three main steps:
1. Converts the circuit into a tensor network and generates a line graph.
2. Creates a contraction plan using the Girvan–Newman algorithm.
3. Performs the sequential contraction of the tensor network based on the generated plan.
"""

using TimerOutputs
import QXZoo.Circuit.Circ



function Calcul_GN_Sequencial(cct::Circ,timings::Bool=true)

    # Reset timing information if enabled
  if timings
        reset_timer!()
    end
   
       
         # Step 1: Convert circuit to tensor network and generate its line graph
    @timeit "1T. Obtaining a line graph" begin
        tnc = convert_to_tnc(cct)  # Convert circuit to tensor network
        light_graf = convert_to_graph(tnc)  # Generate graph representation
        labeled_light_graf = LabeledGraph(light_graf)  # Create a labeled graph
        labeled_line_light_graf = line_graph_tris(labeled_light_graf)  # Generate line graph
    end

    # Step 2: Generate contraction plan using Girvan–Newman algorithm
    @timeit "2T. Getting GN plan" begin
        pla_gn = GN_pla(light_graf, tnc.tn)  # Generate contraction plan
    end
 
    
  # Step 3: Perform final contraction based on the GN plan
    @timeit "3T. Final contraction" begin
        s = contract_tn!(tnc.tn, pla_gn)  # Perform the contraction
    end

    # Print timing results if enabled
    if timings
        print_timer()
    end

    # Return the result of the final contraction
    return s
end

"""
    ComParCPU(circ::Circ, entrada::Vector{Int}, eixida::Vector{Int}, n_com::Int; 
              timings::Bool=true, decompose::Bool=true)

Implements a three-phase tensor network contraction algorithm as described in the paper. 

# Arguments
- `circ::Circ`: The quantum circuit to evaluate.
- `entrada::String`: List of input qubits.
- `eixida::String`: List of output qubits.
- `n_com::Int`: Number of communities to explore.
- `timings::Bool=true`: If `true`, logs and prints timing results for each phase.
- `decompose::Bool=true`: If `true`, decomposes circuit gates into simpler gates.

# Returns
- `Array{ComplexF64, 0}`: The result of the final contraction, representing the amplitude of a given input producing a given output.

# Notes
The function consists of three main phases:
1. Detect communities in the tensor network using the Girvan–Newman (GN) algorithm.
2. Perform parallel contraction within each community.
3. Perform the final sequential contraction using a min-fill plan.
"""

using TimerOutputs
import QXZoo.Circuit.Circ


function ComParCPU(circ::Circ, entrada::String, eixida::String, n_com::Int;timings::Bool=true, decompose::Bool=true)

     # Reset timing information if enabled
    if timings
        reset_timer!()
    end

          # Phase 1: Community detection and graph preparation

          @timeit "1T.Obtaining Communities" begin
               num_qubits = circ.num_qubits  
               # Convert circuit to tensor network
               tnc= convert_to_tnc(circ;no_input=false,no_output=false,input=entrada,output=eixida,decompose=true )                 
               # Convert tensor network to graph and generate its labeled version
               light_graf  = convert_to_graph(tnc)
                               
               labeled__light_graf=LabeledGraph(light_graf);
                 # Generate the line graph and convert to igraph
               labeled_line_light_graf= line_graph_tris(labeled__light_graf); 
   
                h_Lg_ig=lg2ig(labeled__light_graf.graph);
                h_Lg_ig.summary(verbosity=1);

                #Detect communities using Girvan–Newman and compute modularity

                comunitats_julia,comunitats_betwenness,modularitat=labelg_to_communitats_between(labeled__light_graf,n_com);
  
           end 
    
           # Phase 2: Parallel contraction within communities

    
            @timeit "2T.Parallel contraction of communities" begin
  
                    # Generate contraction plans and tensor networks for each community
                    tns,plans= pla_contraccio_multiple_G_N(comunitats_julia,tnc,light_graf)
                    # Perform the first parallel contraction phase
                    c =primera_contraccio_paral(tns,plans);
           
            end 
            
      
                # Phase 3: Final sequential contraction
              @timeit "3T.Final Contraction" begin
              
                  # Generate min-fill plan and perform final contraction
              tw,pla= min_fill_contraction_plan_tw(c)
               
                s=contract_tn!(c, pla)
                
             end

        # Print timing results if enabled
         if timings
            print_timer()
        end

    # Return the result of the final contraction
    return s
end
        
        

    

""""
    ComParCPU_para(circ::Circ, entrada::String, eixida::String, n_com::Int; 
                   timings::Bool=true, decompose::Bool=true)

Implements a three-phase tensor network contraction algorithm with parallelism in the final contraction phase.

# Arguments
- `circ::Circ`: The quantum circuit to evaluate.
- `entrada::String`: List of input qubits.
- `eixida::String`: List of output qubits.
- `n_com::Int`: Number of communities to explore.
- `timings::Bool=true`: If `true`, logs and prints timing results for each phase.
- `decompose::Bool=true`: If `true`, decomposes circuit gates into simpler gates.

# Returns
- `Array{ComplexF64, 0}`: The result of the final contraction, representing the amplitude of a given input producing a given output.

# Notes
This function consists of three phases:
1. Detect communities in the tensor network using the Girvan–Newman (GN) algorithm.
2. Perform parallel contraction within each community.
3. Perform the final contraction with parallelism applied to the initial steps of the contraction plan.
"""


using TimerOutputs
import QXZoo.Circuit.Circ


function ComParCPU_para(circ::Circ, entrada::String, eixida::String,n_com::Int;timings::Bool=true, decompose::Bool=true)
         # Reset timing information if enabled
         if timings
            reset_timer!()
         end


          # Phase 1: Community detection and graph preparation
        @timeit "1T.Obtaining Communities" begin
                               
       

        # Convert circuit to tensor network
        tnc = convert_to_tnc(circ; no_input=false, no_output=false, input=entrada, output=eixida, decompose=decompose)

        # Convert tensor network to graph and generate its labeled version
        light_graf = convert_to_graph(tnc)
        labeled_light_graf = LabeledGraph(light_graf)

        # Generate the line graph and convert to igraph
        labeled_line_light_graf = line_graph_tris(labeled_light_graf)
        h_Lg_ig = lg2ig(labeled_light_graf.graph)
        h_Lg_ig.summary(verbosity=1)

        # Detect communities using Girvan–Newman and compute modularity
         comunitats_julia,comunitats_betwenness,modularitat=labelg_to_communitats_between(labeled_light_graf,n_com);
    end
        
               # Phase 2: Parallel contraction within communities
            @timeit "2T.Parallel contraction of communities" begin
                   # Generate contraction plans and tensor networks for each community  
                    tns,plans= pla_contraccio_multiple_G_N(comunitats_julia,tnc,light_graf)
                   # Perform the first parallel contraction phase
                    c =primera_contraccio_paral(tns,plans);
           
            end 
      
                   # Phase 3: Final contraction with parallelism
                    @timeit "3T.Final contraction in parallel" begin
                
                         # Generate min-fill plan and parallelization details
                          tw,pla= min_fill_contraction_plan_tw(c)
                          pla_mf_p,p  = pla_paral_p(c,pla)
                          # Perform parallel and sequential contractions
                          s= contrau_p(c,pla_mf_p,p)
                    end
    # Print timing results if enabled
    if timings
            print_timer()
        end
# Return the result of the final contraction
return s
end


################################


using TimerOutputs
import QXZoo.Circuit.Circ


"""
    ComParCPU_GHZ(circ::Circ, entrada::String, eixida::String;timings::Bool=true, decompose::Bool=true)

Implements a three-phase tensor network contraction algorithm with parallelism in the final contraction phase.

# Arguments
- `circ::Circ`: The quantum circuit to evaluate.
- `entrada::String`: List of input qubits.
- `eixida::String`: List of output qubits.
- `timings::Bool=true`: If `true`, logs and prints timing results for each phase.
- `decompose::Bool=true`: If `true`, decomposes circuit gates into simpler gates.

# Returns
- `Array{ComplexF64, 0}`: The result of the final contraction, representing the amplitude of a given input producing a given output.

# Notes
This function consists of three phases:
1. Detect communities in the tensor network using the Fast Greedy algorithm.
2. Perform parallel contraction within each community.
3. Perform the final contraction with parallelism applied to the initial steps of the contraction plan.
"""
function ComParCPU_GHZ(circ::Circ, entrada::String, eixida::String;timings::Bool=true, decompose::Bool=true)
    # Reset timing information if enabled
    if timings
        reset_timer!()
    end

    # Phase 1: Community detection and graph preparation
    @timeit "1T.Obtaining Communities" begin
        num_qubits = circ.num_qubits
        tnc = convert_to_tnc(circ; no_input=false, no_output=false, input=entrada, output=eixida, decompose=true)

        # Convert tensor network to graph
        light_graf = convert_to_graph(tnc)

        # Generate labeled graph and line graph
        labeled__light_graf = LabeledGraph(light_graf)
        labeled_line_light_graf = line_graph_tris(labeled__light_graf)

        # Convert to igraph and summarize
        h_Lg_ig = lg2ig(labeled__light_graf.graph)
        h_Lg_ig.summary(verbosity=1)

        # Detect communities using Fast Greedy algorithm
        comunitats_julia, comunitats_betwenness, modularitat = labelg_to_communitats_fastgreedy(labeled__light_graf)
    end

    # Phase 2: Parallel contraction within communities
    @timeit "2T.Parallel contraction of communities" begin
        # Generate contraction plans and tensor networks for each community
        tns, plans = pla_contraccio_multiple_G_N(comunitats_julia, tnc, light_graf)
        
        # Perform the first parallel contraction phase
        c = primera_contraccio_paral(tns, plans)
    end

    # Phase 3: Final contraction with parallelism
    @timeit "3T.Final contraction" begin
        # Generate min-fill plan and perform final contraction
        tw, pla = min_fill_contraction_plan_tw(c)
        s = contract_tn!(c, pla)
    end

    # Print timing results if enabled
    if timings
        print_timer()
    end

    # Return the result of the final contraction
    return s
end



"""
    ComParCPU_para_GHZ(circ::Circ, entrada::String, eixida::String, n_com::Int; 
                   timings::Bool=true, decompose::Bool=true)

Implements a three-phase tensor network contraction algorithm with parallelism in the final contraction phase.

# Arguments
- `circ::Circ`: The quantum circuit to evaluate.
- `entrada::String`: List of input qubits.
- `eixida::String{Int}`: List of output qubits.
- `n_com::Int`: Number of communities to explore.
- `timings::Bool=true`: If `true`, logs and prints timing results for each phase.
- `decompose::Bool=true`: If `true`, decomposes circuit gates into simpler gates.

# Returns
- `Array{ComplexF64, 0}`: The result of the final contraction, representing the amplitude of a given input producing a given output.

# Notes
This function consists of three phases:
1. Detect communities in the tensor network using the Girvan–Newman (GN) algorithm.
2. Perform parallel contraction within each community.
3. Perform the final contraction with parallelism applied to the initial steps of the contraction plan.
"""
function ComParCPU_para_GHZ(circ::Circ, entrada::String, eixida::String;timings::Bool=true, decompose::Bool=true)
    # Reset timing information if enabled
    if timings
        reset_timer!()
    end

    # Phase 1: Community detection and graph preparation
    @timeit "1T.Obtaining Communities" begin
        # Convert circuit to tensor network
        tnc = convert_to_tnc(circ; no_input=false, no_output=false, input=entrada, output=eixida, decompose=decompose)

        # Convert tensor network to graph and generate its labeled version
        light_graf = convert_to_graph(tnc)
        labeled_light_graf = LabeledGraph(light_graf)

        # Generate the line graph and convert to igraph
        labeled_line_light_graf = line_graph_tris(labeled_light_graf)
        h_Lg_ig = lg2ig(labeled_light_graf.graph)
        h_Lg_ig.summary(verbosity=1)

        # Detect communities using Fast Greedy and compute modularity
         comunitats_julia, comunitats_betwenness, modularitat = labelg_to_communitats_fastgreedy(labeled_light_graf)
    end

    # Phase 2: Parallel contraction within communities
    @timeit "2T.Parallel contraction of communities" begin
        # Generate contraction plans and tensor networks for each community
        tns, plans = pla_contraccio_multiple_G_N(comunitats_julia, tnc, light_graf)
        
        # Perform the first parallel contraction phase
        c = primera_contraccio_paral(tns, plans)
    end

    # Phase 3: Final contraction with parallelism
    @timeit "3T.Final contraction in parallel" begin
        # Generate min-fill plan and parallelization details
        tw, pla = min_fill_contraction_plan_tw(c)
        pla_mf_p, p = pla_paral_p(c, pla)
        
        # Perform parallel and sequential contractions
        s = contrau_p(c, pla_mf_p, p)
    end

    # Print timing results if enabled
    if timings
        print_timer()
    end

    # Return the result of the final contraction
    return s
end